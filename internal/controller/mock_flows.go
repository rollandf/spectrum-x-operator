// Code generated by MockGen. DO NOT EDIT.
// Source: flows.go

// Package controller is a generated GoMock package.
package controller

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockFlowsAPI is a mock of FlowsAPI interface.
type MockFlowsAPI struct {
	ctrl     *gomock.Controller
	recorder *MockFlowsAPIMockRecorder
}

// MockFlowsAPIMockRecorder is the mock recorder for MockFlowsAPI.
type MockFlowsAPIMockRecorder struct {
	mock *MockFlowsAPI
}

// NewMockFlowsAPI creates a new mock instance.
func NewMockFlowsAPI(ctrl *gomock.Controller) *MockFlowsAPI {
	mock := &MockFlowsAPI{ctrl: ctrl}
	mock.recorder = &MockFlowsAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFlowsAPI) EXPECT() *MockFlowsAPIMockRecorder {
	return m.recorder
}

// AddHardwareMultiplaneFlows mocks base method.
func (m *MockFlowsAPI) AddHardwareMultiplaneFlows(bridgeName string, cookie uint64, pfNames []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddHardwareMultiplaneFlows", bridgeName, cookie, pfNames)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddHardwareMultiplaneFlows indicates an expected call of AddHardwareMultiplaneFlows.
func (mr *MockFlowsAPIMockRecorder) AddHardwareMultiplaneFlows(bridgeName, cookie, pfNames interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddHardwareMultiplaneFlows", reflect.TypeOf((*MockFlowsAPI)(nil).AddHardwareMultiplaneFlows), bridgeName, cookie, pfNames)
}

// AddHardwareMultiplaneGroups mocks base method.
func (m *MockFlowsAPI) AddHardwareMultiplaneGroups(bridgeName string, pfNames []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddHardwareMultiplaneGroups", bridgeName, pfNames)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddHardwareMultiplaneGroups indicates an expected call of AddHardwareMultiplaneGroups.
func (mr *MockFlowsAPIMockRecorder) AddHardwareMultiplaneGroups(bridgeName, pfNames interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddHardwareMultiplaneGroups", reflect.TypeOf((*MockFlowsAPI)(nil).AddHardwareMultiplaneGroups), bridgeName, pfNames)
}

// AddPodRailFlows mocks base method.
func (m *MockFlowsAPI) AddPodRailFlows(cookie uint64, vf, bridge, podIP string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPodRailFlows", cookie, vf, bridge, podIP)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddPodRailFlows indicates an expected call of AddPodRailFlows.
func (mr *MockFlowsAPIMockRecorder) AddPodRailFlows(cookie, vf, bridge, podIP interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPodRailFlows", reflect.TypeOf((*MockFlowsAPI)(nil).AddPodRailFlows), cookie, vf, bridge, podIP)
}

// AddSoftwareMultiplaneFlows mocks base method.
func (m *MockFlowsAPI) AddSoftwareMultiplaneFlows(bridgeName string, cookie uint64, pfName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddSoftwareMultiplaneFlows", bridgeName, cookie, pfName)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddSoftwareMultiplaneFlows indicates an expected call of AddSoftwareMultiplaneFlows.
func (mr *MockFlowsAPIMockRecorder) AddSoftwareMultiplaneFlows(bridgeName, cookie, pfName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSoftwareMultiplaneFlows", reflect.TypeOf((*MockFlowsAPI)(nil).AddSoftwareMultiplaneFlows), bridgeName, cookie, pfName)
}

// CleanupStaleFlowsForBridges mocks base method.
func (m *MockFlowsAPI) CleanupStaleFlowsForBridges(ctx context.Context, existingPodUIDs map[string]bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanupStaleFlowsForBridges", ctx, existingPodUIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanupStaleFlowsForBridges indicates an expected call of CleanupStaleFlowsForBridges.
func (mr *MockFlowsAPIMockRecorder) CleanupStaleFlowsForBridges(ctx, existingPodUIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanupStaleFlowsForBridges", reflect.TypeOf((*MockFlowsAPI)(nil).CleanupStaleFlowsForBridges), ctx, existingPodUIDs)
}

// DeleteFlowsByCookie mocks base method.
func (m *MockFlowsAPI) DeleteFlowsByCookie(bridgeName string, cookie uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteFlowsByCookie", bridgeName, cookie)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteFlowsByCookie indicates an expected call of DeleteFlowsByCookie.
func (mr *MockFlowsAPIMockRecorder) DeleteFlowsByCookie(bridgeName, cookie interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteFlowsByCookie", reflect.TypeOf((*MockFlowsAPI)(nil).DeleteFlowsByCookie), bridgeName, cookie)
}

// DeletePodRailFlows mocks base method.
func (m *MockFlowsAPI) DeletePodRailFlows(cookie uint64, podID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeletePodRailFlows", cookie, podID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeletePodRailFlows indicates an expected call of DeletePodRailFlows.
func (mr *MockFlowsAPIMockRecorder) DeletePodRailFlows(cookie, podID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePodRailFlows", reflect.TypeOf((*MockFlowsAPI)(nil).DeletePodRailFlows), cookie, podID)
}

// GetBridgeNameFromPortName mocks base method.
func (m *MockFlowsAPI) GetBridgeNameFromPortName(portName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBridgeNameFromPortName", portName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBridgeNameFromPortName indicates an expected call of GetBridgeNameFromPortName.
func (mr *MockFlowsAPIMockRecorder) GetBridgeNameFromPortName(portName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBridgeNameFromPortName", reflect.TypeOf((*MockFlowsAPI)(nil).GetBridgeNameFromPortName), portName)
}

// IsBridgeManagedByRailCNI mocks base method.
func (m *MockFlowsAPI) IsBridgeManagedByRailCNI(bridge, podID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsBridgeManagedByRailCNI", bridge, podID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsBridgeManagedByRailCNI indicates an expected call of IsBridgeManagedByRailCNI.
func (mr *MockFlowsAPIMockRecorder) IsBridgeManagedByRailCNI(bridge, podID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBridgeManagedByRailCNI", reflect.TypeOf((*MockFlowsAPI)(nil).IsBridgeManagedByRailCNI), bridge, podID)
}
